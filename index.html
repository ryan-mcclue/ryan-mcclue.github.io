<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Musings</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Musings</h1>
</header>
<!-- SPDX-License-Identifier: zlib-acknowledgement -->
<p>https://marketplace.fedevel.education/itemDetail.html?itemtype=course&amp;dbid=1569757838995&amp;instrid=us-east-2_KpwYC7yK5:45f6c01d-ccc8-43e0-8f33-c5a70caf707f</p>
<p>Adventures in Creation</p>
<p>can import .stl files and make basic extrusions/pockets</p>
<p>rpi4-case: * container part - container_body · container_body_base:
(centrifically locked; select outer points first) · inlet: vertically
constrain construction line to external geometry * lid part · make
container sketches visible · defining geometry<br />
(link -&gt; union -&gt; transform/create-mesh-shape -&gt; move)</p>
<p>shaft-in-wheel: * revolution pad tool * polar pattern for duplicating
holes around centre domino: * symmetry sketch around centre line *
mirror feature for say entire pad mirroring</p>
<p>when creating lid lips, factor in printer tolerance, say 0.4mm also,
add chamfer/fillet to lip edge</p>
<p>rename pads and pockets</p>
<p>Spreadsheet (have dimensions to make parametric): if want to access
parameteric sketch constraint, &lt;<Sketch>&gt;.Constraints.name
(IMPORTANT: even though variable, make sure to reference it off the
sketch) GIVE OPTIONAL NAME SO CAN REFERENCE FROM .Constraints! (formula
typecasting may be necessary, e.g. (value<em>1mm)) </em>
printer_tolerance * container_l/w/h * board_offset_x/y * case_thickness
* base_thickness * hole_diametre_percent_ratio
(e.g. &lt;<Internal>&gt;.Constraints.height *
hole_diametre_percent_ratio) * global_chamfer</p>
<p>1.75mm PLA (polylactic acid) into 0.4mm nozzle</p>
<p>0.15mm layer height speed/quality 15% infill gyroid
integrity/speed/usage</p>
<p>supports required for model that does not print over itself</p>
<p>export g-code (like printer ISA?) to sd card</p>
<p>supports necessary for complex geometries like overhangs, greater
than 45°, etc. put supports everywhere by default? (perhaps add blockers
to this?) maybe just use everywhere to get a feel for it, then manually
add enforcers?</p>
<p>can also use printrun usb-b interface to print without SD card?</p>
<table style="width:12%;">
<colgroup>
<col style="width: 12%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">most solder has flux core (typically
rosin) to remove oxide films, i.e. wetting the metal (to remove
dirt/grease will require cloth or steel brush) Sn/Pb (60/40) lower
boiling point and shinier finish (cone shaped) then non-leaded. fumes
are flux as boiling point of lead (≈1700°C) much higher fume extractor
at top</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Based on what was trained (LAION 400M
internet scraped image-text pairs, which contains violent and sexual
images (as oppose to DALLE-2)), output may bias, e.g. nerd might bias
towards wearing glasses</td>
</tr>
<tr class="even">
<td style="text-align: left;">txt2img: word:weight, word:weight (must
weights to proceeding works as well to not override) steampunk/low-poly
3D/minecraft rodent, intricate, pen and ink/canon m50, concept art,
aerial in reality, will have different prompt formats for particular,
e.g. architecture
https://www.youtube.com/watch?v=oIAM3loi51s&amp;t=184s</td>
</tr>
<tr class="odd">
<td style="text-align: left;">“a cute magical flying dog, fantasy art,”
“golden color, high quality, highly detailed, elegant, sharp focus,”
“concept art, character concepts, digital painting, mystery, adventure”,
batch_size=3,</td>
</tr>
<tr class="even">
<td style="text-align: left;">A mysterious dark stranger visits the
great pyramids of egypt, high quality, highly detailed, elegant, sharp
focus, concept art, character concepts, digital painting,</td>
</tr>
<tr class="odd">
<td style="text-align: left;">“a pirate ship, clean line art, drawing,
sketching, kitbash 3 d, art by hebron ppg”
https://lexica.art/?q=2ea3ae2a-4c8b-4d64-9c24-0924da5c759d</td>
</tr>
<tr class="even">
<td style="text-align: left;">scale is how close to original?
batch/iterations is how many images to create? Or do we use a custom
script?
https://github.com/AUTOMATIC1111/stable-diffusion-webui/wiki/Custom-Scripts
seems that there are a variety of Stable Diffusion scripts to use,
e.g. https://github.com/jquesnelle/txt2imghd</td>
</tr>
<tr class="odd">
<td style="text-align: left;">img2img: Maintaining likeness: * Euler
over Eular A * Sampling steps removes noise, 15-30 * CFG scale 0.3-0.6 *
Denoise strength 1 * lower CFG scale makes image more honest to original
–&gt; is textual inversion just a variant of img2img keeping
likeness?</td>
</tr>
<tr class="even">
<td style="text-align: left;">interpolated videos: timelapse between
prompts</td>
</tr>
<tr class="odd">
<td style="text-align: left;">outpainting/inpainting: dalle-2 much
better here for photos</td>
</tr>
<tr class="even">
<td style="text-align: left;"># Array Away</td>
</tr>
<tr class="odd">
<td style="text-align: left;">## Matching Pairs A quadratically scaling
solution is intuitive However, as we know every match is unique,
linearly scaling solution obtained with a hash map. C++ STL
implementation of hash tables are sets (just keys) and maps Unordered
variants are raw hash maps Ordered use self-balancing red-black-tree
yielding logarithmic time Simplest hashing function
<code>(x &gt;&gt; 4 + 12) &amp; (size - 1)</code> Important to keep in
mind we are executing on a physical machine and that Big-Oh is a
‘zero-cost abstraction’ world. For example, the extra overhead of
introducing a hashmap (memory allocations/copies) will result in this
being slower for small lists (also no dynamic memory allocations in ISR)
This is why C++ STL uses hybrid introsort</td>
</tr>
<tr class="even">
<td style="text-align: left;">## Sorting Squared Array Quadratic
insertion/bubble sort preferable for small lists Loglinear
divide-and-conquer merge/quick for medium Linear radix for large</td>
</tr>
<tr class="odd">
<td style="text-align: left;">## Tournament Winner In cases space and
size parameters different Can join linear operations populate and
min/max determination</td>
</tr>
<tr class="even">
<td style="text-align: left;"># Workflow Preparation Mentality: ## Git
usage: TODO(Ryan): collate into bash aliases * use gcd function enter
habit to know if out of date * git commit aliases showing diff * find
parents of hash: <code>git rev-list --parents -n 1 &lt;hash&gt;</code> *
locate file content:
<code>git log -S'content' -- file_name | tr '\n' ' '</code> * locate
file added/deleted/modified/renamed:
<code>git log --diff-filter=A -- foo.js</code> * previous commit
messages:
<code>git show --color -s --format='%C(yellow)(%as)%C(reset) %s' -5 | tr '~' ' '</code>
<strong>merge commit with previous commit</strong>:
<code>git rebase -i HEAD~n</code> a standard rebase will apply commits
on top of interactive rebase to perform squashing on most recent
<strong>merge conflict resolution</strong>:
<code>git mergetool</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">although sh in containers (alpine linux),
the ubiquity of bash (if git on windows, then have bash) use its
features</td>
</tr>
<tr class="even">
<td style="text-align: left;">if global, decide if actually global or
thread-local</td>
</tr>
<tr class="odd">
<td style="text-align: left;">TODO: investigate analysing core dump
files (when becomes necessary)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Updating compiler symlinks: $(sudo ln
-vfns /usr/bin/gcc-10 /usr/bin/gcc)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">TODO: breakpoint/error function print out
line information only in debug builds</td>
</tr>
<tr class="even">
<td style="text-align: left;">Files from templates are developed on each
project, thereby iteratively improving</td>
</tr>
<tr class="odd">
<td style="text-align: left;">TODO: Andrew Reece (rethinking doxygen
youtube live streams)</td>
</tr>
<tr class="even">
<td style="text-align: left;">TODO: doesn’t asynchronous programming
just make things harder to debug? is performance of say linux io_uring
any better than synchronous?</td>
</tr>
<tr class="odd">
<td style="text-align: left;">TODO(Ryan): Investigate useful POSIX C
functions, e.g. nftw() (netfw.h), getaddrinfo() (netdb.h) Also, some
require the definition of cryptic macros to be included</td>
</tr>
<tr class="even">
<td style="text-align: left;">TODO: aaron codes, code yao (leetcode
walkthroughs)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">TODO: way to reduce transparency of active
window dynamically?</td>
</tr>
<tr class="even">
<td style="text-align: left;">DIFFERENCE IN APPROACH TO WORKING ON TEAM
AND STAGE OF PROJECT on a team, ‘proper’ commit should change one thing
and have accompanying tests. So, write explorative code on branch and
merge when done</td>
</tr>
<tr class="odd">
<td style="text-align: left;">have a _COUNT at the end of every
enum</td>
</tr>
<tr class="even">
<td style="text-align: left;">perhaps start with this:
https://github.com/TheSandvichMaker/netgame and improve with glenn
fielder? glenn fielder networking codersblock javidx9 mmo (possible
informative videos: https://www.youtube.com/watch?v=jmHQa5P7hC8,
https://www.youtube.com/watch?v=9OjIDko1uzc)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">techlinked + michel tunnell (this week in
linux)</td>
</tr>
<tr class="even">
<td style="text-align: left;">does mesa stack include open-source
drivers for NVIDIA. so, support opengl and vulkan?</td>
</tr>
<tr class="odd">
<td style="text-align: left;">sudo and pipes doesn’t work. to allow gdb
to attach: $(sudo bash -c “echo 0 &gt;
/proc/sys/kernel/yama/ptrace_scope”) sudo -i; sudo vim
/etc/sysctl.d/10-ptrace.conf IMPORTANT(This seems to work): sudo
/sbin/setcap CAP_SYS_PTRACE=+eip /usr/bin/gdb</td>
</tr>
<tr class="even">
<td style="text-align: left;">TODO: GO THROUGH https://www.rfleury.com/
articles and implement!!!! mr4thdimension (allen webster) youtube videos
https://mr4th.com/</td>
</tr>
<tr class="odd">
<td style="text-align: left;">TODO: With strncpy and such, get some
indication if didn’t write entire buffer, i.e. input buffer too
small</td>
</tr>
<tr class="even">
<td style="text-align: left;">TODO: variable sized data structures that
use memory arena with no holes</td>
</tr>
<tr class="odd">
<td style="text-align: left;">TODO: use sanitisers from get go (may
catch when mallocs less than a page)</td>
</tr>
<tr class="even">
<td style="text-align: left;">TODO: structure code for cross-platform
from get go</td>
</tr>
<tr class="odd">
<td style="text-align: left;">TODO: terminator tab autoopen for project
(include file in project source)</td>
</tr>
<tr class="even">
<td style="text-align: left;">TODO: avoid using magic numbers for
various buffer sizes</td>
</tr>
<tr class="odd">
<td style="text-align: left;">TODO: prefix discriminated union
fields</td>
</tr>
<tr class="even">
<td style="text-align: left;">TODO: write more comments on code that is
‘exploratory’, e.g. ASSUMES static size, IGNORES clearing other fields,
etc.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Good error messages say what happened and
why, provide reassurance, are empathetic, and help users fix the
problem.</td>
</tr>
<tr class="even">
<td style="text-align: left;">When working with array, always check if
length &gt; 0</td>
</tr>
<tr class="odd">
<td style="text-align: left;">For production, probably want to
<code>dlopen()</code> to provide fallbacks for missing libraries</td>
</tr>
<tr class="even">
<td style="text-align: left;">TODO: some sort of code review on merge
requests</td>
</tr>
<tr class="odd">
<td style="text-align: left;">TODO: writing expansive tests (perhaps
look at zeux github?)</td>
</tr>
<tr class="even">
<td style="text-align: left;">always in software development will have
things that aren’t working optimally. know they are there. will later go
back and fix them when required (e.g. when in quality improving mode).
just know this will always happen</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Working with modern software is going to
be a pain at some point. Have to stay strong and not belittle situation,
rather accept it and move on. At times, have to get off high horse and
roll up your sleeves.</td>
</tr>
<tr class="even">
<td style="text-align: left;">Linux issues: 1. runtime configurability
(difficult part not API, but what to do when settings aren’t exact,
i.e. what to fall back on when abstraction not there). 2. multiple
binaries Although possible to dynamically load core libraries like
xlib/wayland/alsa and support a minimum set of APIs, this is essentially
what SDL does. However, system/user configurability is huge in linux.
There is simply too much runtime variability to test for all users.
Furthermore, multiple CRT to support, e.g. muslc for Alpine</td>
</tr>
<tr class="odd">
<td style="text-align: left;">One way to solve variability is to use the
Steam Runtime, which is a collection of .so files and configuration that
is less subject to user configuration</td>
</tr>
<tr class="even">
<td style="text-align: left;">Linux desktop suffers from binary
compatibility nightmare, e.g. 15 binaries to support all. This is
because libraries like glibc are happy to break abi to get minor
improvements, e.g spec says this so let’s do it even though no one
cares</td>
</tr>
<tr class="odd">
<td style="text-align: left;">C STL has one version for each compiler +
os. also, some compilers might not fully implement the STL feature</td>
</tr>
<tr class="even">
<td style="text-align: left;">With an undeclared identifier in a unity
build, just reorder #includes in main file</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Cross platform naming, e.g. With libc,
libraries is more of a discipline thing There are no absolutes, just
tradeoffs for solving your problem, e.g raw vs smart pointers Often
issue is not hard code, it’s because the problem is messy, I. E.
Unwritten assumptions, external constraints, users want lots of generic
functionality. So often interesting at the same time, very
annoying.</td>
</tr>
<tr class="even">
<td style="text-align: left;">Data structures don’t correspond to layout
in memory, e.g. When would you want awful cache locality of linked
list</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Frameworks change all the time,
fundamentals not so much, e.g how things glue together</td>
</tr>
<tr class="even">
<td style="text-align: left;">compression orientated program think about
concept compression, rather than code compression. e.g. might be at such
a small code size that there is no concept to really compress</td>
</tr>
<tr class="odd">
<td style="text-align: left;">combinations: 2ⁿ-1, max: 2ⁿ introducing
negatives we effectively remove one bit numbers represented in twos
complement to handle addition/subtraction of negatives and positives.
not because of representation, e.g. sign bit would work fine when saying
complement, it’s with respect to negative number handling: ones ➞ invert
all bits in positive number to get negative. therefore have -0 twos ➞
adding a positive and its negative will get a 2 in each place. think
about the MSB as the negative place, hence why -1 is all 1s</td>
</tr>
<tr class="even">
<td style="text-align: left;">FPGA (matrix of CLBs) reprogrammable (as
oppose to ASIC) IC with HDL. Better for parallel processing?</td>
</tr>
<tr class="odd">
<td style="text-align: left;">dave’s garage, what’s a creel</td>
</tr>
<tr class="even">
<td style="text-align: left;">Switching between laptop and desktop as
uni student meant merge conflicts were common. So, know how to fix with
$(git mergetool) and have it as a rebase</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Github issue and pull request template
files
(https://embeddedartistry.com/blog/2017/08/04/a-github-pull-request-template-for-your-projects/?mc_cid=a5a0d2dbbf&amp;mc_eid=UNIQID)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Terminal + Editor + Window manager</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Important to have linux source so as to
view Documentation folder $(make kernelversion)
https://www.youtube.com/watch?v=Jl_0W4o0xao</td>
</tr>
<tr class="even">
<td style="text-align: left;">(Serial Advanced Technology Attachment)
important that these are sustained speeds, so for small file sizes
expect a lot less as seconds smaller note that storage space advertised
with S.I units, whilst OS works with binary</td>
</tr>
<tr class="odd">
<td style="text-align: left;">RAM potentially hundreds of cycles (CAS
latency and cache retrieval process) (important to note that RAM CAS is
only say 20% of total latency as will check traverse cache and than copy
it to cache)
https://sites.utexas.edu/jdm4372/2011/03/10/memory-latency-components/
In general: check if in L1. If not go check in L2 and mark least
recently accessed L1 for move to L2. bubbles up to L3 until need for
memory access which will go to memory controller etc.</td>
</tr>
<tr class="even">
<td style="text-align: left;">so, ram frequency gives max. throughput
however latency of ram also important</td>
</tr>
<tr class="odd">
<td style="text-align: left;">(cache latency from wikichip)</td>
</tr>
<tr class="even">
<td style="text-align: left;">generic is referencing Ubuntu specific
kernel compilation (could also have -lowlatency etc.) (generic does not
include a lot of modules in kernel to alleviate RAM, so use modprobe)
(-41 is build number, i.e how many times compiled) (the compiler,
linker, libc are all specific to linux OS used, e.g. compiled with
different settings, different versions, etc.)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">$(grub-install -V) /etc/default/grub
(GRUB_CMDLINE_LINUX_DEFAULT=““); $(update-grub); $(cat /proc/cmdline)
(acpi_enforce_resources=lax boot parameter to allow decode-dimms to find
ram chip) Tentative to make boot changes, e.g. kernel parameters due to
previous issues whereby performing a grub install on a loopback device
affected the system’s existing EFI GUID. To alleviate these concerns,
carry copy of ubuntu on USB to mount and backup regularly</td>
</tr>
</tbody>
</table>
<p>Don’t restrict right side of bell curve Let your aces be aces Being
an ace involves having an opinion Most influential software written
largely by one person, e.g Linux, Unix, git etc. Then a team is assigned
to maintain it. Fallacy about solo programmer productivity requiring
large teams. Design by committee pushes design to middle of bell curve
as opposing views average out</p>
<p>Cpu try to guess what instructions ahead (preemptive). Cost of
incorrect reflushing expensive. So want to get rid of conditional jumps.
Ideally replace with conditional movs or arithmetic branch less
techniques. Endianness (register view), twos complement (-1 all 1s)
Branch less programming is essentially SIMD</p>
<p>What simd instructions available to cpu? If variable clock speed, cpu
could detect not using all cores and increase single core clock</p>
<p>Flops calculated with best instruction set? Not memory bound is best
case for hyper threading Intel speeds optimised for gpr arithmetic,
boolean and flops Why is Intel shr instruction so slow? Intel
deliberately makes mmx slow —–</p>
<p>For intel CPUs, i3-i7 of same generation will have same
micro-architecture. Just more cache, hyperthreading, cores, die size
etc.</p>
<p>$(grub-)</p>
<p>Intel clock frequency is often changed by OS?</p>
<p>Is cortex-m4 microarchitecture? How does this relate to intel naming?
AMD also?</p>
<p>also have uOP cache considered L0</p>
<p>$(getconf LEVEL1_DCACHE_LINESIZE)</p>
<p>$(sudo lshw -html &gt; info.html) for RAM, harddrive and drivers of
things $(ldd –version) $(lsb_release -a), $(cat /etc/debian_version)</p>
<p>SATA ssd is the lowest grade ssd (however still 4 times
bandwidth)</p>
<p>storage devices: form factor (M.2 keying, PCIe), interface (SATAIII,
NVMe, PCIe), technology a single form factor may support multiple
interfaces, so ensure motherboard has appropriate chipset</p>
<p>DRAM refreshed periodically. SDRAM (synchronises clock speed with
memory speed). SDRAM. LPDDR4 (low-power; double pumping on rising and
falling edge of clock)</p>
<p>SRAM more expensive, faster, not refreshed, larger die size.</p>
<p>DIIM (dual in-line memory module) is form factor (wider bus) SODIMM
(small outline)</p>
<p>From $(cpuinfo) see that although 64bit cpu this is just what the
instruction set supports. As we have no need for 16 exabytes (tera,
peta, exa), the physical address size may be 39bits, and virtual size
48bits to save on unused transistors</p>
<p>$(cpu-x) for cache information per core</p>
<p>NUMA node relationship between CPU socket (location on motherboard)
and memory banks. So, say 2 sockets will probably have 2 NUMA nodes.
Therefore, not all physical memory directly accessible from 1 cpu
socket; will have to go through other socket to get it</p>
<p>Hyperthreads don’t increase number of instructions per second, rather
number of instructions that can be queued (so hyperthread like a
queue)</p>
<p>Caches, are instruction and data caches combined? What distinct
features in a core, e.g. shared caches? What additional features on one
capable of hyperthreading?</p>
<p>CPU could implement VT-x, but motherboard and bios must support this
as well? What additional features are present when CPU supports
this?</p>
<p>Cache probably 8-way as compromise between lookup and copy speed.
Flow of cache, is it check if from 8-way copy then L2 8-way or finish L1
entirely? If found, in L2 does it copy to L1?</p>
<p>Polymorphism is a single object that can be interpreted as having
various types. This can simply be a struct with unions and a type
field.</p>
<p>Never use setters/getters unless actually doing something. You’re
spending your entire day typing. If needing, replace variable name with
name_ to see where it was used.</p>
<p>You need to be self critical to be a good engineer</p>
<p>Caches are a way of minimising roundtrip time of RAM by putting
memory as close to the core that thinks will need it L1 closest, 1/2
cycles, 32k. Wikichip for more info Cpu will go to caches first</p>
<p>L1 can supply 2 cache lines per clock Instructions per clock, number
of work components, e.g. number of add components, cache line per
cycles, cache latency, agu (address resolver units) impose restrictions
A cache miss is simply stalling for an instruction. However, this may
not be an issue if we do other work, e.g. complex algorithm takes many
instructions hiding memory access for out of order cpu. If hyper
threading with two schedulers, if cache miss on one, just switch to the
other. Can really only know if a cache miss incurs a performance penalty
by looking at raw numbers from vtune, etc. Because of the scheduler,
it’s not as simple as just looking at memory sizes So, due to complex
overlapped/scheduling nature of modern CPUs can really only know if
cache miss incurs penalty with vtune Uop website displays table for
instructions</p>
<p>Currently good that most things are little endian with 64 byte cAche
lines, however some hardware guys Is going to come along and change it
back to big endian</p>
<p>Should be code of ethics in software to not create
bugs/inconveniences for users that couldve been avoided</p>
<p>An instruction of throughput 1 means issued every clock. As many
instructions take longer than 1 cycle, each core requires a scheduler to
see if it can execute something. View cpu as sections where there is
some distance to communicate.</p>
<p>Making some thing good takes time. However, if you have crazy design
practices it will also take longer You have to be reality based when
programming. That is in an engineering sense, to design something that
solves the problem you have People become attached to a way of
programming which doesn’t focus on solving the problem. They want to
build rube-goldberg machines Selectively attacking problems seriously
means you have a functional program quicker, whereby you can actually
decide if those other problems need to be addressed. Can defer hard
decisions later as they will be made better as you will have more
technical expertise and more context to work with</p>
<p>Testing is important. If you don’t write tests, your software doesn’t
work. However, write higher level system tests, not excessive unit
tests. More efficient and this is where bugs are likely to be. You often
have to remove code, so having unit tests just increases the volume of
code you have to write. Huge drain on productivity. Maybe for NASA. A
new paradigm should weigh up cost-benefit. Almost always the cost is
ignored and people gobble them up</p>
<p>To make computers better to use, have to simplify them on all
levels</p>
<p>Faster cpu like Apple’s m1 are irrelevant if software bad</p>
<p>Floating point math faster than integers</p>
<p>my style of programming and problems enjoy solving found in embedded,
e.g your constrained with the silicon not like in web where you just
build another data centre</p>
<p>Compiler works on file by file, so knows nothing about calls across
files. Therefore it generates object files which are partially
executable machine code with unresolved symbols. Linker merges these
object files and also adds extra header information so that the OS can
load our executable (or more specifically a kernel, e.g. linux)</p>
<p>Complete code coverage on the one hand is very thorough, however
don’t get a lot of engineering output. Furthermore, most bugs appear in
between systems not in units.</p>
<p>Best way to test is to release on early access. This checks hardware
and software, user may be running adobe acrobat which hogs cpu so
instruct them to kill it before running your game. Or maybe 20000 chrome
plugins. This is something a hardware lab can’t tell you</p>
<p>Process is allocated virtual memory space OS has mapping table that
converts these to physical addresses. Part of our processes address
space is pre-populated by the kernel program loader, e.g.  linux-vdso,
environment variables, etc. Kernel tunables: sudo sh -c ‘echo
kernel.perf_event_paranoid=0 &gt;&gt; /etc/sysctl.d/local.conf’ (sysctl)
User tunables: ulimit -a In virtual address space, have user space and
kernel space address ranges. A virtual address is mostly relating to
page table indexes and the last bit is a static offset (as for security
addresses are randomized)</p>
<p>To make an installer just fwrite your executable and then data files
appended with footer. Inside the exe, fread the exe and fseek based on
the static offset of the appended resources Bake resources in for
reliability only really</p>
<p>Packed files better as less OS operations performing expensive file
handles etc.</p>
<p>Programming about solving problem. overlooked by design philosophies.
If you don’t have any functionality, you don’t have a structural
problem</p>
<p>const is only useful if you find it catches bugs for you (maybe for
globals instead of using #defines) however, in terms of optimsations,
const is useless as you can cast const away. therefore, for me, const is
mostly just a waste of typing. however, have to use for strings in C++
In a similar vein, VLAs useful here (note that sizeof(array) and
sizeof(pointer) for calculating string array count)</p>
<p>distinct areas of memory in assembly are stack, heap and data
(globals)</p>
<p>direction of stack growth is often determined by CPU. if selectable,
then OS. eg. x86 is downwards ulimit -s for stack size</p>
<p>good practice to assign variable for syntatical reasons, i.e. more
readable, e.g Controller *controller =
&amp;evdev_input_device.controller;</p>
<p>getconf can list POSIX system configurable variables</p>
<p>don’t go through a ton of unecessary stdlib. malloc probably more
optimised for small memory size requests relative to overall code base,
interfacing with system calls is not that much code (and can be
reused)</p>
<p>if we try to access memory from an invalid page (not reserved or
comitted) will get segfault. only have to worry about errors that don’t
manifest themselves on every run of the program.</p>
<p>on x86, writing by 32bit faster than 8bit as less instructions in
general, the fastest way is to use the widest possible register that can
be operated on at once the speed of accessing the memory from cache is
pretty cheap for nearby regions</p>
<p>don’t make changes for conceptual cleanliness. end of the day, want
to make performant, bug free code in the shortest amount of time.</p>
<p>when programming some days you are off. this just means you’re going
to be debugging a lot</p>
<p>we want it to be clear what our code can and cannot touch. global
variables make this hard (however, can add _ to see where they are all
used) however, as many OSs are rather janky and most code will live
outside this, it is ok to have some globals here globals are fine in
development. can repackage into a structure later.</p>
<p>clock speed not as relevent as improvements in microarchitecture and
number of cores means can be more efficient under less duress. also,
lower clock speed may be because want to draw less power.</p>
<p>short build times (under 10 seconds) are incredibly important to not
decentivness making changes and testing them</p>
<p>function overloading, generalised operator overloading and default
arguments are c++ features that can’t easily be implemented with gcc
extensions</p>
<p>note that &gt;&gt; will typically (implementation defined) perform
arithmetic shift (fill in with 1’s) on signed, so not always the same as
a divide. similarly, sign-extension just fills in the new MSBs with
1’s</p>
<p>for large cross-platform projects, best to differentiate with
filenames, rather than ifdefs. this also gives the ability to have
different control flows across the different platforms (essential)</p>
<p>for a game, better to have the game as a service to the OS (not the
other way round). this is becuase the game does not need to know/perform
the myriad of possible operations the OS can perform.</p>
<p>most modern cpus have a floating point unit, making them faster than
ints (same latency), e.g. a multiply is one instruction where ints is
two (multiply and shift) x87 is the FPU instructions for x86 (also have
SSE instructions which is want you ultimately want) however, for
multiplayer games, optimisers can give different results when using
floating point, e.g a platform that has operator fusion like a MULADD
may give different result when rounding then a platform that has do it
separate. (fixed point could solve this)</p>
<p>Programming Mentality: always important to know when coding what is
your goal. premature optimisation and design are bad. your goal
dictactes the quality of the code you write, e.g. allowed to be janky as
first pass on API. write usage code first.</p>
<p>often when having a variable lengthed array, ask ourselves do we
really need that?</p>
<p>asserts are part of debug program that are used to check that things
work that should always work. use them for a condition that must be true
that is not explicitly present</p>
<p>don’t think about memory management, but rather memory usage. if
having to worry about freeing etc. done something wrong.</p>
<p>when writing ‘spec’ code, no need to handle all cases; simply note
down the edge cases you should handle later on stop yourself thinking
about whether the code is messy or not. only care once problem is
solved!</p>
<p>it’s not the programming practice but the dogma that gets you. when
you start to name things it almost always becomes bad. almost all
programming practices have a place, just not used often so RAII people,
in case of things that must be released, e.g DeviceContext, ok to use a
constructor/destructor pair. I’ll throw you a bone there</p>
<p>streaming i/o is almost never a good choice (hard drive slowest, more
errors)</p>
<p>compression orientated programming is you code what you need at the
time (breaking out into function, combining into struct, etc.) over time
the code marches towards a better overall quality</p>
<p>amdahls law gives the time taken for execution given a number of
cogives the time taken for execution given a number of cores. for this
formula (indeed any formula) we can obtain some property by seeing as
function parameter approaches infinity. in this case, the parallelising
part drops out. brooks law says that simply adding more people to a
problem does not necessarily make it faster. if requires great deal of
coordination/communication actually slows down.</p>
<p>solving a problem: 1. decide what you are doing (this can’t be
open-ended.) 2. organise groups to achieve this by making these
boundaries, we are presupposing that each part is separate, e.g tyres
team and engine team; assume tyres and engine cannot be one piece.
therefore, the boundaries define what products you can make, i.e. you
produce products that are copies of yourself or how you are structured
so, in software if we assign teams for say audio, 2d, 3d we would expect
individual APIs for each. the org chart is the asymptote, so it’s the
best case that we make a product as granular as our org chart. it could
be far worse and even more granular therefore, communication between
teams is more costly than communication within teams. takeaway is that
low-cost things can be optimised, high-cost can’t be (further away on
the org chart) note that communication in code could just be someone
checking something in and you pulling it what we are seeing now with
modern software is the superposition of orgcharts due to use of legacy
codebases now we see org charts in software, where people are
artifically creating inheritence hierarcies that limit how the program
works this is very bad. the reason it’s done is for people to create
mental models that help them solve the problem as they can’t keep the
complexity in their head. it may be necesary to solve the problem,
however it shouldn’t be looked at as good. however, because it’s done
due to lack of understanding, the delegation/separation is not done with
enough information. so you limit possibilities of the design space. so
although, libraries, microservices, encapsulation, package managers,
engines may be necessary due to our brain capacity (until neuralink or
we figure out a better way to do them) they are not good! we may use
hash map, but only in a particular way They limit optimisation as we
have already decided separation so always be on the lookout for times
when you don’t have to do these most people just download hundreds of
libraries because they know it works and they won’t be worse than any
one else. WE MUST BE LEAN AND FLEXIBLE IN ORGCHARTS IN COMPANY AND IN
SOFTWARE TO INCREASE DESIGN. some old codebases need to be retired</p>
<p>DO THE ‘MOST CERTAIN’ THING FIRST. THIS COULD EITHER BE THE
IMPLEMENTATION OR THE USAGE CODE choose data structures around solving
problem</p>
<p>some software is scaffolding, i.e. not shipped with the final
product, e.g. editor for games</p>
<p>To make anything alternate over time, just multiply by
sine(time);</p>
<p>Data hiding hides what the CPU is doing, which is what we care
about</p>
<p>Require machine-specific documentation files to understand system we
are on System specific ctags template projects, e.g. linux kernel,
glibc, etc. If using library, have ctags for that project</p>
<p>ALMOST ALWAYS CAST TO FLOAT WHEN DOING DIVISIONS LEADING TO FLOAT</p>
<p>Minimum value starts at max</p>
<p>Spreading out randomness:
<code>final_value += contrib * sample</code></p>
<p>If debug code (or code that will not be in release) use compile-time
macros</p>
<p>Use GLOBAL and global_prefix If casting is occuring, always be
explicit about it! Prefixing functions with sdl2_func() or linux_func()
only if intending to be cross-platform</p>
<p>With error handling, bad practice is to allow a lot of errors, which
brings in error classes etc. Instead, if it’s something that is actually
an error, e.g. missing file, write the code to explicitly handle it.
Handling the error in a sense makes it no longer an error, rather a
feature of the program</p>
<p>if function is expecting a range between, should we clamp to it?</p>
<p>Refactoring Mentality: Refactoring is essential. You must know what
you are trying to achieve so you have some notion of progress,
e.g. adding a constraint to the system. (Replacing variable type in
scope gives us all locations where variable was used, including macros.
This us where dynamic lnguages fail as you don’t know if you broke
something)</p>
<p>You can abstract/encapsulate anything at anytime, so why not do it
later when you know what you are doing? We want file format to be simple
and binary, unlike json which is general purpose and string</p>
<p>modifying (parse as pointer arg), returning (result struct). it is
best to put simple types are arguments rather than a group struct to
allow for maximum code reuse. only put group struct as arguments if must
be put together (in general don’t pack so don’t force user to create a
struct when they may already have the values)</p>
<p>if can go functional without sacrificing, saves you complexity down
the road. oftentimes simply utilising elements of functional programming
is good, e.g. no global state, only operating on parameters etc.</p>
<p>writing code guides you to the right design, e.g. made same call
-&gt; put into function; require args in function -&gt; struct; many
related functions together -&gt; organise related functions into own
file; (if thinking could be moved to another file, make comment sections
outlining code blocks to ease this process later on) etc. (these are
simple, compression changes), complex api -&gt; transient struct,
overload functions for internal/external use There are also large
changes that are more difficult, e.g.  sections of single value
interpreted differently -&gt; pack 2 variables into 1 (_ technique
useful here) same operations performed on pairs of variables -&gt;
vectors (as oppose to working with them as scalars) vectors are
particularly useful as without them repeated actions quickly become
intractable It can get messy at times, but always know that a clean
solution is out there and you will refine towards it Work threw the
error tree one at a time Important to throw in asserts for underlying
assumptions. Also for debugging be aware of ‘copy-pasta’, e.g. copying
variables will have same name for two parameters as didn’t replace
it</p>
<p>we don’t want to orient our code around objects (if anything,
algorithmic oriented). its about how you arrive at some code that
determines how good it is</p>
<p>excessive pre-planning and setting waypoints is really only useful if
you’ve done the problem before (which in that case you’re not really
designing) instead, we become a good pathfinder, learning to recognise
the gradient of each day of the journey. when write the simplest thing
and loft it out into good design later (in this explorative phase, if we
make an changes for efficiency reasons we have just introduced the
possibilities of bugs with no benefit)</p>
<p>only break into function when you know what you want, e.g. called
multiple times or code finalised and improved readability (in which case
a tradeoff is made between understanding functionality and
semantics)</p>
<p>Don’t be scared of mass name changing!! Before doing so, see all
places where name is used Don’t be scared of long list of compiler
errors. Work your way through them</p>
<p>Refactoring with usage code: just write out structures that satisfy
the usage code. If major rewrite use #if 0 #endif to allow for
successful compiling</p>
<p>refactoring just copy code into function that gets it to compile.
later, worry about passing information in as a parameter basic debug and
release compiler flags When refactoring, utilise our vimrc <C-F> all
files Also, just pull code out into desired function and let the
compiler errors guide you Returning multiple values, just return struct
To reduce large number of function parameters, put into struct</p>
<p>Debugging Mentality: debugging stepping through pass-by-pass.
inspecting all variables and parameters and verifying state of
particular ones. make deductions about state of variables, e.g
overflowed, uninitialised, etc. drop in asserts draw it out</p>
<p>being able to draw out debug information is very useful. time spent
visualising is never wasted (in debugger expressions also)</p>
<p>When debugging, look through variables and see if anything looks
ridiculous</p>
<p>When in debugger, go iteratively progress through variable values in
function and see if they look right We can isolate some area of the code
and say this is probably the problem Then investigate relevent
sub-functions, etc. This can be a long process with seemingly little
gains. The issue could be subtle, e.g. signed/unsignedness size,
function called rarely</p>
<p>Configuration files should be copied, not generated (becomes too
messy) Symlink to template files from projects</p>
<p>To begin, I ensured that I had a debugger from which I could easily
step through the application’s execution. In code, I was able to
programmatically set system and user breakpoints.</p>
<p>(mocking of syscalls for unit testing with file i/o)</p>
<p>For handling non-fatal errors, single line check. For fatal errors,
nest all preceding code (I have learnt to not be afraid of indentation
in this manner). (error handling in general, i.e. reduce ‘errors’ by
making them part of normal execution flow)</p>
<p>When performing the common task of grouping data, a few practices to
keep in mind. Use fixed sized types to always know about struct padding
(in fact, I like to extend this to all my code)</p>
<p>If wanting multiple ways of accessing grouped data, use union and
anonymous structs. Use an int to reference other structs,
e.g. <code>plane_index</code></p>
<p>If the data being grouped can only exist together (e.g. points), use
vectors. Put all structs related typedefs inside their own header file
for easy access.</p>
<p>As floats are an approximation, when comparing to 0.0f (say for a
denominator check) or negative (say for a square root) use a
tolerance/epsilon less-than/greater-than check. In fact whenever
dividing should always ask oneself “can the value be zero?” To be clear
about float to int casting, use a macro like truncate/round (think about
what if uneven divide) Due to mixed integer and float arithmetic going
to float, calculate integer percentages <code>val * 100 / total</code>
There is no need to overload the division operator as can do
<code>(* 1.0f / val)</code></p>
<p>For easy substitution, use single letter prefix names like
<code>output_h</code> and <code>output_w</code>. Convention for variable
arrays, e.g. <code>Planes plane[1]</code>, <code>planes</code> and
<code>plane_count (use ARRAY_COUNT macro here)</code> Put for loop
statements on separate line to help not be afraid of indentation.
Iterate over pixel space and then convert to say, world space for
calculations (normalisation and lerp) Aspect ratio correction is simply
rearranging a ratio. If we determine one side is larger, scale other.
Use “ ASCII code to print a status indicator. Only use const for char *
string literals stored in the data segment.</p>
<p>Endianness comes into play when reading/writing from disk (e.g. file
type magic value) and working directly with <code>u8 *</code>
(e.g. iterating through bytes of a u32)</p>
<p>MARKETING APP: f5bot.com,
https://github.com/lawxls/HackerNews-personalized I’m notified when
keywords related to “human wants thing, my app can do thing” appear on
HN, Reddit and Lobsters. If I can then contribute with information to
that discussion, I’ll also leave a link to my app. Don’t just self plug,
people (myself included) appreciate more detailed information on how
they can solve their own personal problem, instead of being thrown into
“here’s an app, figure it out”</p>
<p>time -p; getrusage();</p>
<p>callbacks less CPU intensive than polling</p>
<p>Saying one instruction is faster than the other ignores context of
execution. e.g. mul and add same latency, however due to pipelining mul
execution unit might be full TLS vs atomics, e.g. TLS is series of
instructions determined by OS and compiler. Atomics depend on how other
cores are run and synchronising necessary with other cores So, must
measure which is faster for particular situation</p>
<p>use $(time) for single line, use $(ctime)</p>
<p>Can pin a thread to a core</p>
<p>Can run programs in kernel space with eBPF</p>
<p>Frequent context-switching will give terrible cache coherency</p>
<p>adding <code>restrict</code> also useful to prevent aliasing and
thereby might allow compiler to vectorise say array loops</p>
<p>Before cpus increased in single thread execution speed. Now more
cores. It’s a topic of research to convert single threaded into
multithreaded for emulation. This is why emulation of something like the
GameCube (powerpc) is slow. Furthermore, due to hardware irregularities
that programs relied on may take hundreds of instructions to emulate If
actually a simple translation, then should run close to native speed.
This is reality of emulating hardware with hardware</p>
<p>CISC gives reduced cache pressure for high-intensive, sustained
loops</p>
<p>log2(n) number of bits for decimal
https://en.algorithmica.org/hpc/cpu-cache/associativity/</p>
<p>using genetic algorithm/machine learning to optimise for us
https://zeux.io/2020/01/22/learning-from-data/</p>
<p>Cpu try to guess what instructions ahead (preemptive). Cost of
incorrect reflushing expensive. So want to get rid of conditional jumps.
Ideally replace with conditional movs or arithmetic branch less
techniques. Endianness (register view), twos complement (-1 all 1s)
Branch less programming is essentially SIMD</p>
<p>If variable clock speed, cpu could detect not using all cores and
increase single core clock</p>
<p>Not memory bound is best case for hyper threading Intel speeds
optimised for GPR arithmetic, boolean and flops Intel deliberately makes
mmx slow</p>
<p>Low cache associativity means fast lookup but a lot of misses and
thus eviction policy like LRU</p>
<p>Count cycles to counteract possible thermal throttling Hyperthreads
useful only if different execution unit Cpu reads memory from cache and
ram in cache lines (due to programmer access patterns). Each item in
cache set is cache line size</p>
<p>if apple computers use RISC ARM in M1, why CISC necessary? (only
because on Intel?) emphasis of CISC simplify assembly (e.g. more
addressing modes), thereby reducing size of binary? (reduce
instructions) and increase cache coherency RISC will require less
transistors to implement complex hardware but will make optimising
harder for compiler? single cycle instructions (reduce cycles per
instruction)</p>
<p>when looking at a pointer, to optimise compiler must know whether it
can assume it points to a local var or not. so, easier to eliminate
aliasing with non-pointers</p>
<p>when viewing from application in a sandboxed environment like a
phone, total RAM less than installed as portion reserved for kernel</p>
<p>simplistically RAM 50ns and HDD 10µs? faster to read than write</p>
<p>2.5bln * 8 (simd) * n (execution units) * 2 (cores) assuming
instructions have throughput of 1 so 64 / 4 gives how many floats per
second from L1 cache in general, not streaming from memory the entire
time (would probably hit a cache bandwidth limit)</p>
<p>// undefined behaviour if not true ALWAYS_INLINE void assume(bool
cond) { if(!(c)) {__builtin_unreachable()}; } times when manual inlining
is required: https://www.youtube.com/watch?v=B2BFbs0DJzw</p>
<p>Unless your in web where everything takes years to load, as single
threaded performance is largely stagnant you will have to utilise
parallelism if want performance. This is very difficult and like single
threaded code generic libraries which can actually be very specific will
create bloated in performing code based. Multithreading is building up a
new discipline to single threaded. There are a lot of pitfalls for
performance (balancing want things local, however must share to utilise)
If you care about performance for anything, you should care about cache
misses Memory bandwidth and caches are major reasons for a cup attaining
performance. You have to think about where does memory actually live and
how is it transferred around</p>
<p>Optimiser allows for lexical scoping of stack variables. However, for
optimiser to inline will have to get rid of pointers to prevent
aliasing</p>
<p>stack and heap memory are the same physical thing, so only more
efficient if memory was hot, i.e. recently touched</p>
<p>Computer faster than you think, e.g instructions, clock cycles,
cores. Very large With M2 drive should be quick</p>
<p>may be easier for optimising compiler to work with things passed by
value as oppose to pointer. so, if need to modify something may have to
return the value in a functional programming style. however, this is
error prone. compiler cannot optimise pointers, e.g. if setting two
values to same pointer, compiler cannot say that both the values are the
same as another pointer may point to the same address. this is
aliasing.</p>
<p>we see contiguous memory in virtual memory, however in physical
memory it is almost certainly going to be fragmented</p>
<p>compilers can auto-vectorize loops for us (and other operations if we
perform say 20 of them). so, floats will be twice as fast as doubles
(more space, even though same latency and throughput)</p>
<p>optimising is a very precise process. only do when you have code that
is working and you know will keep. games by their very nature are about
responsiveness, so optimisation and low-latency is important. I like
programming with this as a mentality.</p>
<p>with pure compiler optimisations, i.e. code we have not optimised
ourselves, a 2x increase is not unexpected. (code we optimised not as
much)</p>
<p>optimise for worst case (looking out on whole world) not best case
(in front of wall, don’t render what is behind). we care about highest
framerate, not lowest.</p>
<p>virtually never use lookup tables as ram memory is often 100x slower
(so unless you can’t compute in 100 of instructions)</p>
<ol type="1">
<li>Optimisation (this is rarely done due to time involved) Do
back-of-envelope calculations; look at algorithm to see if wasteful;
benchmark to see if hitting theoretical calculations and then use
timings etc. to isolate why our code isn’t hitting these theoretical
numbers Very importantly need to know what the theoretical maximum is,
which will be dependent on the program, e.g bounded by number of bytes
sent to graphics card, kernel stdout etc.</li>
<li>Non-pessimisation (do this all the time) Don’t introduce unecessary
work (interpreter; complex libraries; constructs like
polymorphism/classes people have convinced themselves are necessary) for
the CPU to do to solve the problem</li>
<li>Fake optimisation (very bad philosophy) Repeating context-specific
statements e.g. use memcpy as it’s optimised (however the speed of
something is so context specific, so non-statement), arrays are faster
than linked lists (again, so dependent on what your usage patterns are)
IMPORTANT: In programming, preface the suitability of something to a
particular environment/context</li>
</ol>
<p>When many people say too much effort involved in optimisation, they
are generally thinking of point 1</p>
<p>sometimes things should be running faster than they should, however
only so much we can replace e.g. the structure of many OSs are based on
legacy code, so simply outputting to stdout may go through shell then
kernel etc. also, may have to deal with pessimised libraries. in these
cases: * isolate bad code, i.e. draw hard boundary between your code and
theirs by caching calls to them * do as little modification to the data
coming in from them (no need to say put in a string class etc.)</p>
<p>People think that it’s slow, but it won’t crash (because of
interpreter) Performance is critical in getting people excited about
what you do, e.g. windows ce was laggy, iphone performant but less
features changes the market low latency is more desirable, even if less
features</p>
<p>count number of math ops in function and control flow logic that is
evaluated branches can get problematic if they’re unpredictable</p>
<p>inspecting measurements of microarchitecture consider latency and
throughtput (how much does it cost to start again) so, FMUL may have
latency of 11, however throughput of 0.5, so can start 2 every cycle,
i.e. issue again (cpus these days are incredibly overlapped even if
single-threaded) so throughput is more of what we care about for
sustained execution, e.g. in a loop</p>
<p>however, these numbers are all assuming the data is in the chip. it’s
just as important to see how long it takes to get data to the chip. look
at cache parameters for microarchitecture; how many cycles to get from
l1 cache, l2 cache, etc. when get to main memory potentially hundreds of
cycles</p>
<p>bandwidth of L1 cache say is 80 bytes/cycle, so can get 20 floats per
cycle (however, based on size of L1 cache, not really sustainable for
large data)</p>
<p>http://igoro.com/archive/gallery-of-processor-cache-effects/</p>
<p>(could just shortcut this and just see if flops is recorded for our
chip)</p>
<p>so, using these rough numbers we should be able to look at an
algorithm (and dissect what operations it’s performing, like FMULs),
know how much data it’s taking, and give a rough estimate as to how long
it could optimally take (will never hit optimal however) IT’S CRITICAL
TO KNOW HOW FAST SOMETHING SHOULD RUN</p>
<p>REASONS SOFTWARE IS SLOW: 1. No back-of-envelope calculations (people
aren’t concerned that they are running up to 1000 times slower thn what
the hardware is capable of) These calculations involve say looking at
number of math ops to be performed in the algoirthm and comparing that
to the perfect hardware limit 2. Reusing code (20LOC is a lot; use
things that do what you want to do, but not in the way you want them to
be done; often piling up code that is ill-fitting to what the task was,
e.g. we know this isn’t a regular ray cast, it’s a ray cast that is
always looking down) 3. When writing, thinking of goals ancillary to
task (not many places taught how to actually write code; all high level
abstractions about clean code there are thinking about templates/classes
etc. not just what does the computer actually have to do to do this
task?) (there is no metric for clean code; it’s just some fictional
thing people made up)</p>
<p>WHENEVER UNDERSTANDING CODE EXAMPLES: 1. COMPILE AND STEP INTO (NOT
OVER) IN DEBUGGER AND MAKE HIGH LEVEL STEPS PERFORMED look at these
steps for duplicated/unecessary work (may pollute cache). (perhaps even
asking why was the code written the way it was) could we gather things
up in a prepass, i.e. outside of loop? if allocating memory each cycle
that’s game over for performance. do we actually have to perform the
same action to get the same result, e.g. a full raycast is not
necessary, just segment on grid O(n·m) is multiplicative, not linear
O(n). big oh is just indication of how it scales. could be less given
some input threshold (big oh ignores constants, hence looking at
aymptotic behaviour, i.e. limiting behaviour) now, once code reduced,
look at minimising number of ops</p>
<p>cpu front end is figuring out what work it has to do,
i.e. instruction decoding</p>
<p>e.g simd struct is 288 bytes, 4.5 cache lines, able to store 8
triangles</p>
<p>understanding assembly language is essential in understanding why the
code might not be performing well</p>
<p>branch prediction necessary to ensure that the front-end can keep
going and not have to wait on the back-end</p>
<p>execution ports execute uops. however, the days of assembly language
registers actually mapping to real registers is gone. instead, the
registers from the uops are passed through a register allocation table
(if we have say 16 general purpose registers, table has about 192
entries; so a lot more) in the back-end this is because in many
programs, things can happen in any order. so to take advantage of this,
the register allocation table stores dependency chains of operations
(wikichips.org for diagram) from execution port, could be fed back into
scheduler or to load/store in actual memory</p>
<p>when looking at assembly, when we say from memory, we actually mean
from the L1 cache</p>
<p>xmm is a sse register (4 wide, 16 bytes); m128 is a memory operand of
128 bits ymm is 8 wide 1<em>p01 + 1</em>p23 is saying issue 1 microop on
either port0 or port1 and one microop on either port2 or port3 so, we
could issue the same instruction multiple times, i.e. throughput of
0.5</p>
<p>microop fusion is where a microop doesn’t count for your penalty as
it’s fused with another. with combined memory ops,
e.g. <code>vsubps ymm8, ymm3, ymmword ptr [rdx]</code> this is the case
so, if a compiler were to separate this out into a mov and then a sub,
not only does this put unecessary strain on the front-end decoder it
also removes microop fusion as they are now separate microops (important
to point out that I’m not the world best optimiser, or the worlds best
optimisers assistant, so perhaps best not to outrightly say bad codegen,
just say makes nervous)</p>
<p>godbolt.org good for comparing compiler outputs and possible
detecting a spurious load etc.</p>
<p>macrop fusion is where you have an instruction that the front-end
will handle for you, e.g. add and a jne will merge to addjne which will
just send the 1 microp of add through</p>
<p>uica.uops.info gives percentage of time instruction was on a port
(this is useful for determining bottle-necks, e.g. series of
instructions all require port 1 and 2, so cannot paralleise easily) so,
although best case say is issue instruction every 4 cycles, this
bottleneck will give higher throughput</p>
<p>some levels of abstraction are necessary and good, e.g. higher level
languages to assembly</p>
<p>Optimise: gather stats -&gt; make estimate -&gt; analyse efficiency
and performance</p>
<p>file size https://justine.lol/sizetricks
https://codegolf.stackexchange.com/questions/215216/high-throughput-fizz-buzz/236630#236630</p>
<p>more important to understand how CPU and memory work than language
involved in an OS, you will get given a zero-page due to security
concerns</p>
<p>likely() macros for branch prediction compiler optimisations
(https://akkadia.org/drepper/cpumemory.pdf, pg 56)</p>
<p>recording information: We want to understand where slow with vtune,
amd uprof, arm performance reports Next, determine if IO bound, memory
bound etc.</p>
<p>To determine performance must have some stable metric, e.g. ops/sec
to compare to e.g measure total time and number of operations
Hyper-threading useful in alleviating memory latency, e.g. one thread is
waiting to get content from RAM, the other hyper-thread can execute
However, as we are not memory bound (just going through pixel by pixel
and not generating anything intermediate; will all probably stay in L1
cache), we are probably saturating the core’s ALUs, so hyper-threading
not as useful</p>
<p>Inspecting the assembly of our most expensive loop, we see that
rand() is not inlined and is a call festival. This must be replaced
Essentially we are looking for mathematical functions that could be
inlined and aren’t that are in our hot-path. When you want something to
be fast, it should not be calling anything. If it does, probably made a
mistake Also note that using SIMD instructions, however not to their
widest extent, i.e. single scalar ‘ss’. Want to replace with ‘ps’ packed
scalar</p>
<p>we have the option of constructor/destructor pairs if we want to
determine best possible time if all caches align etc. ‘hunt for
mininum’, e.g. record mininum time execution in loop iteration or re-run
if smaller time yielded alternatively, we could develop a statistical
breakdown of values (could see moments when kernel switches us out
etc.)</p>
<p>(IMPORTANT save out configuration and timing information for various
optimisation stages, e.g. ./app &gt; 17-04-2022-image.txt)</p>
<p>agnerfog optimise website ‘what’s a creel’</p>
<p>threading Observe CPU percentage use is not close to 100% For
multithreading, often have to pack into 64 bit value to perform single
operation on it,
e.g. <code>delta = (val1 &lt;&lt; 32 | val2); interlocked_add(&amp;val, delta)</code></p>
<p>When making multi-threaded, segregate task by writing prototype
‘chunk’ function, e.g. <code>render_tile</code> Then write a for loop
combining these chunk functions Before entering the chunk function, good
to have a configuration printout, e.g. num chunks, num cores, chunk dim,
chunk size, etc.</p>
<p>When dividing a whole into pieces, an uneven divisor will give less
than what’s needed. so <code>(total + divisor - 1) / divisor</code> to
ensure always enough. We will want this calculation to be in the last
dividing operation, e.g. tile_width then tile_count calculated, so use
on tile_count Associated with this calculation is clamping to handle
adding extra exceeding original dimensions For getting proper place in
chunk, call function wrapper for pointer location per row</p>
<p>(May have to inline functions?) Next we want to pass each chunk onto
a queue and then dequeue them from each logical core? So, have a
WorkOrder that will store all information required to perform operation
on chunk, i.e. all parameters in <code>render_chunk</code> function (may
also store entropy for each chunk, i.e. random number series) Then a
WorkQueue that contains an array of WorkOrders with total number
equalling number of chunks So, the original loop iterating of chunks now
just populates the WorkOrders Now in a while loop that runs while there
are still chunks to execute, we call the <code>render_chunk</code>
function and pass in the WorkQueue The <code>render_chunk</code>
function will increment the next_work_order_index and return true if
more to be done</p>
<p>When spawning the actual worker thread functions, have same while
loop calling the <code>render_chunk</code> function as for core 0 (the
amount of threads to spawn would think should be equal to number of
logical cores? however exceeding them may increase performance?) (this
debate of manually prescribing the core count applies to the chunk size
as well. perhaps the sweet-spot for my machine in balancing context
switching and drain out is to manually prescribe their size as oppose to
computing them off the core count) (Collating information into the
WorkQueue struct helsp for printing out configuration) (Setting up this
way, we can easily turn multithreading off)</p>
<p>As creating threads will require platform specific, put prototypes in
main.h and the implementations in linux_main.cpp Then include
linux_main.cpp based on macro definition of platform in the build script
at the bottom of main.cpp</p>
<p>hyperthreading, architecture specific information becomes more
important when in a situation where memory is constrained in relation to
the cache (hyper-threads share same L1-L2 cache)</p>
<p>volatile says code other than what is generated by this compiler run,
could modify this value. it’s required for multithreaded, as compiler
may not re-read value that it may have cached in a register if changed
elsewhere when incrementing volatiles, must use a
locked_add_and_return_previous_value (could return new value, just be
clear)</p>
<p>simd clamp can be re-written as min() and max() combination, which
are instructions in SSE Although looking at the system monitor shows
cpus maxed out, we could be wasting cycles, e.g. not using SIMD</p>
<p>Define lane width, and divide with this to get the new loop count Go
through loop and loft used values e.g. lane_r32, lane_v3, lane_u32
(IMPORTANT at first we are only concerned with getting single values to
work, later can worry about n-wide loading of values) (TODO the current
code has the slots for each lane generated, rather than unpacked. look
at handmade hero for this unpacking mode) If parameters to functions,
loft them also (not functions? just parameters? however we do
random_bilateral_lane() so yes to functions?) If using struct or struct
member references, take out values and loft them also,
e.g. sphere.radius == lane_r32 sphere_r; (group struct remappings
together) Remap if statement conditions into a lane_u32 mask and remove
enclosing brace hierarchy (IMPORTANT you can still have if statements if
they apply to lanes, e.g. if mask_is_zeroed() break;) (TODO for
mask_is_zeroed() we want the masks to be either all 1’s or 0’s) (call
mask_is_zeroed() on all masks to early out as often as possible to get a
speed up) Once lofted all if statements, &amp; all the masks into a
single mask (it seems if there is large amounts of code inside the if
statements, you don’t want to do it this way and rather check if needing
to execute?) (IMPORTANT to only &amp; dependent masks, e.g. if there is
an intermediate if like a pick_mask or clamp, then don’t include it, but
do the conditional assign directly on this mask) Then enclose remaining
assignments in a conditional assignment function using this single mask?
(conditional_assign(&amp;var, final_mask, value); this uses positive
mask to get source and negative mask to get dest?) (also discover the
work around to perform binary operations on floating point numbers) So,
by end of this all values operated upon should be a lane type? (can have
some scalar types if appropriate) We may have situation where some items
in a lane may finish before others. So, introduce a lane_mask variable
that indicates this. To indicate say a break, we can do (lane_mask =
lane_mask &amp; (hit_value == 0)); For incrementing, will have to
introduce an incrementor value that will be zeroed out for the
appropriate lane item that has finished. Have horizontal_add()? Next
once everything remapped create a lane.h. Here, typedef the lane types
to their single variants to ensure working before adding actual simd
instructions Also do simd helper functions like horizontal_add(),
mask_is_zeroed() in one dimension first Wrap the single lane helper
functions and types in an if depending on the lane width set (IMPORTANT
any functions that we are to SIMD, place here. if it comes that we want
actual scalar, then rename with func_lane prefix)</p>
<p>for simd typically have to organically transition from AOS to SOA</p>
<p>Debug in single lane, single threaded mode (easier and debugger
works) However, can increase lane width as needed (threading not so
much?)</p>
<p>For bitwise SIMD instructions, the compiler does not need to know how
we are segmenting the register, e.g. 4x8, 8x8 etc. as the same result is
obtained performing on the entire register at once. So they only provide
one version of it, i.e. no epi32 only si128 Naming convention have
types: <code>__m128 (float), __m128i (integer), __m128d (double)</code>
and names in functions:
<code>epi32/si128 (integer), ps (float), pd (double)</code> Overload
operators on actual wide lane structs (IMPORTANT remember to do both
orders, e.g. (val / scalar) and (scalar / val)) Also have conversion
functions</p>
<p>Lane agnostic functions go at bottom (like +=, -=, &amp;=, most v3
functionality) (IMPORTANT it seems we can replace logical &amp;&amp; and
|| with binary for same functionality in simd)</p>
<p>(IMPORTANT simd does not handle unsigned conversions, may have to cut
off sign bit, e.g. &gt;&gt; 1)</p>
<p>process of casting type to pointer to access individual bytes or
containing elements (used in file reading too)</p>
<p>(IMPORTANT masks in SIMD will either be all 1’s or 0’s. perhaps have
a specific name for this to distinguish?)</p>
<p>(IMPORTANT seems that not all operations are provided in SSE, like
!=, so have to implement with some bitwise operations)</p>
<p>SIMD allows divide by zeros by default? (because nature of SIMD have
to allow divide by zeroes?)</p>
<p>To get over the fact that C doesn’t allow &amp; floating point,
reinterpret bit paradigm <code>*(u32 *)&amp;a</code> as oppose to cast
(IMPORTANT in SIMD cast is reinterpreting bits, so the opposite of cast
in C)</p>
<p>caching https://akkadia.org/drepper/cpumemory.pdf 1. know cache sizes
to have data fit in it 2. know cache line sizes to ensure data is close
together (may have to separate components of structs to allow loops to
access less cache lines) i.e. understand what you operate on frequently.
may also have to align struct 3. simple, linear access patterns (or
prefetch instructions) for things larger than cache size</p>
<p>inline assembly (raw syscalls from github) HAVE TO INSPECT/VERIFY
ASSEMBLY IS SANE FIRST THEN LOOK AT TIMING INFORMATION inspecting
compiler generated assembly loops, look for JMP to ascertain looping
condition due to macro-op fusion (relevent to say Skylake), e.g. cmp-jmp
non-programmable instructions could be executed by the cpu similarly,
instructions that only exist on the frontend but exist programmatically
e.g. xmm to xmm might just be a renaming in register allocation table
also due to concurrent port usage, can identify parts of code as
relatively ‘free’ struct access typically off a [base pointer] in
assembly, 1.0f might be large number e.g. 1065353216 in assembly loop,
repeated instructions may be due to loop unrolling we might see: *
superfluous loading of values off stack * more instructions required,
e.g not efficiently using SIMD (often this exposes the misconception
that compilers are better than programmers; so better to handwrite
intrinsics)</p>
<p>comparing unoptimised assembly to ‘wc’ see noticeable speed increase.
example of non-pessimisation</p>
<p>Following the basic principles of non-pessimisation, I make a note of
the huge amount of cruft in the C STL. The output buffering, hidden
<code>malloc()</code> ‘optimisations’ (uncommitted memory, encounter
expensive page faults later; prefer reliability/clarity over
edge-performance benefits), OS line ending conversions, non-obvious use
of mutexes etc. Whilst these may seem like minor inconveniences, they
can be insidious for performance, e.g. <code>rand()</code> has a huge
call-stack that if we replace with a simple xor shift, results in 3x
speed up. Although easy to criticise, it may be the situation that the
CRT had to be that way because of C standards. To isolate use of the
CRT, wrap in functions so we can hopefully replace with system calls,
intrinisics, etc. Although generally okay to use STL, it forces you to
use their patterns (e.g. memory allocation, locks etc.). This is true
for STLs in general across all languages. Some may have bloatness from
other areas, e.g. C++ templates To avoid the compiler having to generate
a large export table of all functions, make them <code>static</code> To
avoid large amounts of linking and ∴ increase compilation time, have a
unity build. Furthermore, garunteed ability to inline functions (as with
multiple translation units, possible one might only have function
declaration and not definition) (issues may occur with slower
incremental builds when including 3rd party libraries; yet, can still
work around this possibly using ccache)</p>
</body>
</html>
